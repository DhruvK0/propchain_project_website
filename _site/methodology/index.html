<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Methodology | PropChain</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="/assets/style.css">
  <link rel="icon" href="/assets/favicon.ico">
</head>
<body>
  <div class="parallax">
  <section id="methodology" class="parallax__layer parallax__layer--base">
    <div class="section-content">
      <h2>Methodology</h2>
      <p>
        PropChain is built on a foundation of cutting-edge technologies and innovative approaches. Here’s how we did it:
      </p>
      <ul>
        <li>
          <strong>Blockchain Technology</strong>: 
          At the heart of PropChain is blockchain, a decentralized and distributed ledger technology. Blockchain ensures that all transactions are:
          <ul>
            <li><strong>Immutable</strong>: Once recorded, data cannot be altered or deleted, ensuring trust and security.</li>
            <li><strong>Transparent</strong>: Every transaction is publicly visible and verifiable by all participants.</li>
            <li><strong>Decentralized</strong>: No single entity controls the network, reducing the risk of fraud and manipulation.</li>
          </ul>
          We used <strong>Ethereum</strong>, a leading blockchain platform, to build PropChain. Ethereum supports smart contracts, which are essential for automating real estate transactions.
        </li>
        <li>
          <strong>Smart Contracts</strong>: 
          Smart contracts are self-executing programs that run on the blockchain. They automatically enforce the terms of an agreement when predefined conditions are met. Here’s how they work in PropChain:
          <ul>
            <li><strong>Automation</strong>: Smart contracts automate processes like escrow, title transfers, and payments. For example, when a buyer and seller agree on terms, the smart contract holds the funds in escrow and releases them only when all conditions (e.g., title transfer, inspection) are satisfied.</li>
            <li><strong>Transparency</strong>: The code of the smart contract is publicly visible on the blockchain, ensuring that all parties can verify its logic and fairness.</li>
            <li><strong>Security</strong>: Once deployed, the smart contract cannot be altered, eliminating the risk of tampering or fraud.</li>
          </ul>
          Smart contracts are written in <strong>Solidity</strong>, a programming language specifically designed for Ethereum. They are deployed on the Ethereum Virtual Machine (EVM), which executes the code in a secure and decentralized manner.
        </li>
        <li>
          <strong>Front-End Interface</strong>: 
          Our user-friendly interface allows buyers and sellers to easily search for properties, initiate transactions, and track progress in real time. The design prioritizes simplicity and accessibility, making it easy for anyone to use. The front-end is built using modern web technologies like <strong>React.js</strong> and connects to the blockchain via <strong>Web3.js</strong>, a library that enables interaction with Ethereum-based applications.
        </li>
        <li>
          <strong>Property Verification</strong>: 
          To ensure the accuracy of property listings, we implemented a verification system that uses geolocation data and EXIF tags from uploaded photos. In the future, we plan to integrate AI to further enhance this process by analyzing photos for consistency with the property’s location.
        </li>
        <li>
          <strong>ERC-20 Token System</strong>: 
          Users earn <strong>ERC-20 tokens</strong> for verifying properties, creating a community-driven approach to maintaining accurate listings. These tokens can be used within the PropChain ecosystem. This incentivizes participation and reduces the need for costly third-party verification services.
        </li>
      </ul>
    </div>
  </section>
</div>

  
  <script>
    // Intersection Observer for fade-in animations
    document.addEventListener('DOMContentLoaded', function() {
      // Observe section content for fade-in
      const sectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            
            // Find all fade-in elements within this section
            const fadeElements = entry.target.querySelectorAll('.fade-in');
            fadeElements.forEach(el => {
              el.classList.add('visible');
            });
            
            // Update active nav dot
            const sectionId = entry.target.parentElement.id;
            updateActiveDot(sectionId);
          }
        });
      }, { threshold: 0.2 });
      
      // Observe all section contents
      document.querySelectorAll('.section-content').forEach(section => {
        sectionObserver.observe(section);
      });
      
      // Create navigation dots
      createNavDots();
      
      // Smooth scroll for navigation dots
      document.querySelectorAll('.nav-dot').forEach(dot => {
        dot.addEventListener('click', function() {
          const targetId = this.getAttribute('data-target');
          document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
        });
      });
    });
    
    // Create navigation dots function
    function createNavDots() {
      const sections = document.querySelectorAll('section');
      const navDotsContainer = document.createElement('div');
      navDotsContainer.className = 'nav-dots';
      
      sections.forEach(section => {
        const dot = document.createElement('div');
        dot.className = 'nav-dot';
        dot.setAttribute('data-target', section.id);
        navDotsContainer.appendChild(dot);
      });
      
      document.body.appendChild(navDotsContainer);
      
      // Set first dot as active
      if (navDotsContainer.firstChild) {
        navDotsContainer.firstChild.classList.add('active');
      }
    }
    
    // Update active navigation dot
    function updateActiveDot(sectionId) {
      document.querySelectorAll('.nav-dot').forEach(dot => {
        if (dot.getAttribute('data-target') === sectionId) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });
    }
  </script>
</body>
</html>